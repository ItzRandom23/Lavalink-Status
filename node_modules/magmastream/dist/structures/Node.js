"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
const tslib_1 = require("tslib");
const Utils_1 = require("./Utils");
const Rest_1 = require("./Rest");
const nodeCheck_1 = tslib_1.__importDefault(require("../utils/nodeCheck"));
const ws_1 = tslib_1.__importDefault(require("ws"));
class Node {
    options;
    /** The socket for the node. */
    socket = null;
    /** The stats for the node. */
    stats;
    manager;
    /** The node's session ID. */
    sessionId;
    /** The REST instance. */
    rest;
    static _manager;
    reconnectTimeout;
    reconnectAttempts = 1;
    /** Returns if connected to the Node. */
    get connected() {
        if (!this.socket)
            return false;
        return this.socket.readyState === ws_1.default.OPEN;
    }
    /** Returns the address for this node. */
    get address() {
        return `${this.options.host}:${this.options.port}`;
    }
    /** @hidden */
    static init(manager) {
        this._manager = manager;
    }
    /**
     * Creates an instance of Node.
     * @param options
     */
    constructor(options) {
        this.options = options;
        if (!this.manager)
            this.manager = Utils_1.Structure.get("Node")._manager;
        if (!this.manager)
            throw new RangeError("Manager has not been initiated.");
        if (this.manager.nodes.has(options.identifier || options.host)) {
            return this.manager.nodes.get(options.identifier || options.host);
        }
        (0, nodeCheck_1.default)(options);
        this.options = {
            port: 2333,
            password: "youshallnotpass",
            secure: false,
            retryAmount: 30,
            retryDelay: 60000,
            priority: 0,
            ...options,
        };
        if (this.options.secure) {
            this.options.port = 443;
        }
        this.options.identifier = options.identifier || options.host;
        this.stats = {
            players: 0,
            playingPlayers: 0,
            uptime: 0,
            memory: {
                free: 0,
                used: 0,
                allocated: 0,
                reservable: 0,
            },
            cpu: {
                cores: 0,
                systemLoad: 0,
                lavalinkLoad: 0,
            },
            frameStats: {
                sent: 0,
                nulled: 0,
                deficit: 0,
            },
        };
        this.manager.nodes.set(this.options.identifier, this);
        this.manager.emit("nodeCreate", this);
        this.rest = new Rest_1.Rest(this);
    }
    /** Connects to the Node. */
    connect() {
        if (this.connected)
            return;
        const headers = Object.assign({
            Authorization: this.options.password,
            "Num-Shards": String(this.manager.options.shards),
            "User-Id": this.manager.options.clientId,
            "Client-Name": this.manager.options.clientName,
        });
        this.socket = new ws_1.default(`ws${this.options.secure ? "s" : ""}://${this.address}/v4/websocket`, { headers });
        this.socket.on("open", this.open.bind(this));
        this.socket.on("close", this.close.bind(this));
        this.socket.on("message", this.message.bind(this));
        this.socket.on("error", this.error.bind(this));
    }
    /** Destroys the Node and all players connected with it. */
    destroy() {
        if (!this.connected)
            return;
        const players = this.manager.players.filter((p) => p.node == this);
        if (players.size)
            players.forEach((p) => p.destroy());
        this.socket.close(1000, "destroy");
        this.socket.removeAllListeners();
        this.socket = null;
        this.reconnectAttempts = 1;
        clearTimeout(this.reconnectTimeout);
        this.manager.emit("nodeDestroy", this);
        this.manager.destroyNode(this.options.identifier);
    }
    reconnect() {
        this.reconnectTimeout = setTimeout(() => {
            if (this.reconnectAttempts >= this.options.retryAmount) {
                const error = new Error(`Unable to connect after ${this.options.retryAmount} attempts.`);
                this.manager.emit("nodeError", this, error);
                return this.destroy();
            }
            this.socket?.removeAllListeners();
            this.socket = null;
            this.manager.emit("nodeReconnect", this);
            this.connect();
            this.reconnectAttempts++;
        }, this.options.retryDelay);
    }
    open() {
        if (this.reconnectTimeout)
            clearTimeout(this.reconnectTimeout);
        this.manager.emit("nodeConnect", this);
    }
    close(code, reason) {
        this.manager.emit("nodeDisconnect", this, { code, reason });
        if (code !== 1000 || reason !== "destroy")
            this.reconnect();
    }
    error(error) {
        if (!error)
            return;
        this.manager.emit("nodeError", this, error);
    }
    message(d) {
        if (Array.isArray(d))
            d = Buffer.concat(d);
        else if (d instanceof ArrayBuffer)
            d = Buffer.from(d);
        const payload = JSON.parse(d.toString());
        if (!payload.op)
            return;
        this.manager.emit("nodeRaw", payload);
        let player;
        switch (payload.op) {
            case "stats":
                delete payload.op;
                this.stats = { ...payload };
                break;
            case "playerUpdate":
                player = this.manager.players.get(payload.guildId);
                if (player)
                    player.position = payload.state.position || 0;
                break;
            case "event":
                this.handleEvent(payload);
                break;
            case "ready":
                this.rest.setSessionId(payload.sessionId);
                this.sessionId = payload.sessionId;
                if (this.options.resumeStatus) {
                    this.rest.patch(`/v4/sessions/${this.sessionId}`, {
                        resuming: this.options.resumeStatus,
                        timeout: this.options.resumeTimeout,
                    });
                }
                break;
            default:
                this.manager.emit("nodeError", this, new Error(`Unexpected op "${payload.op}" with data: ${payload.message}`));
                return;
        }
    }
    async handleEvent(payload) {
        if (!payload.guildId)
            return;
        const player = this.manager.players.get(payload.guildId);
        if (!player)
            return;
        const track = player.queue.current;
        const type = payload.type;
        let error;
        switch (type) {
            case "TrackStartEvent":
                this.trackStart(player, track, payload);
                break;
            case "TrackEndEvent":
                if (player?.nowPlayingMessage && player?.nowPlayingMessage.deletable) {
                    await player?.nowPlayingMessage?.delete().catch(() => { });
                }
                this.trackEnd(player, track, payload);
                break;
            case "TrackStuckEvent":
                this.trackStuck(player, track, payload);
                break;
            case "TrackExceptionEvent":
                this.trackError(player, track, payload);
                break;
            case "WebSocketClosedEvent":
                this.socketClosed(player, payload);
                break;
            default:
                error = new Error(`Node#event unknown event '${type}'.`);
                this.manager.emit("nodeError", this, error);
                break;
        }
    }
    trackStart(player, track, payload) {
        player.playing = true;
        player.paused = false;
        this.manager.emit("trackStart", player, track, payload);
    }
    async trackEnd(player, track, payload) {
        const { reason } = payload;
        // If the track failed to load or was cleaned up
        if (["loadFailed", "cleanup"].includes(reason)) {
            this.handleFailedTrack(player, track, payload);
        }
        // If the track was forcibly replaced
        else if (reason === "replaced") {
            this.manager.emit("trackEnd", player, track, payload);
            player.queue.previous = player.queue.current;
        }
        // If the track ended and it's set to repeat (track or queue)
        else if (track && (player.trackRepeat || player.queueRepeat)) {
            this.handleRepeatedTrack(player, track, payload);
        }
        // If there's another track in the queue
        else if (player.queue.length) {
            this.playNextTrack(player, track, payload);
        }
        // If there are no more tracks in the queue
        else {
            await this.queueEnd(player, track, payload);
        }
    }
    extractSpotifyTrackID(url) {
        const regex = /https:\/\/open\.spotify\.com\/track\/([a-zA-Z0-9]+)/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    extractSpotifyArtistID(url) {
        const regex = /https:\/\/open\.spotify\.com\/artist\/([a-zA-Z0-9]+)/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    // Handle autoplay
    async handleAutoplay(player, track) {
        const previousTrack = player.queue.previous;
        if (!player.isAutoplay || !previousTrack)
            return;
        const hasSpotifyURL = ["spotify.com", "open.spotify.com"].some((url) => previousTrack.uri.includes(url));
        if (hasSpotifyURL) {
            const node = this.manager.useableNodes;
            const res = await node.rest.get(`/v4/info`);
            const info = res;
            const isSpotifyPluginEnabled = info.plugins.some((plugin) => plugin.name === "lavasrc-plugin");
            const isSpotifySourceManagerEnabled = info.sourceManagers.includes("spotify");
            if (isSpotifyPluginEnabled && isSpotifySourceManagerEnabled) {
                const trackID = this.extractSpotifyTrackID(previousTrack.uri);
                const artistID = this.extractSpotifyArtistID(previousTrack.pluginInfo.artistUrl);
                let identifier = "";
                if (trackID && artistID) {
                    identifier = `sprec:seed_artists=${artistID}&seed_tracks=${trackID}`;
                }
                else if (trackID) {
                    identifier = `sprec:seed_tracks=${trackID}`;
                }
                else if (artistID) {
                    identifier = `sprec:seed_artists=${artistID}`;
                }
                if (identifier) {
                    const recommendedResult = (await node.rest.get(`/v4/loadtracks?identifier=${encodeURIComponent(identifier)}`));
                    if (recommendedResult.loadType === "playlist") {
                        const playlistData = recommendedResult.data;
                        const recommendedTrack = playlistData.tracks[0];
                        if (recommendedTrack) {
                            player.queue.add(Utils_1.TrackUtils.build(recommendedTrack, player.get("Internal_BotUser")));
                            player.play();
                            return;
                        }
                    }
                }
            }
        }
        const hasYouTubeURL = ["youtube.com", "youtu.be"].some((url) => previousTrack.uri.includes(url));
        let videoID = previousTrack.uri.substring(previousTrack.uri.indexOf("=") + 1);
        if (!hasYouTubeURL) {
            const res = await player.search(`${previousTrack.author} - ${previousTrack.title}`, player.get("Internal_BotUser"));
            videoID = res.tracks[0].uri.substring(res.tracks[0].uri.indexOf("=") + 1);
        }
        let randomIndex;
        let searchURI;
        do {
            randomIndex = Math.floor(Math.random() * 23) + 2;
            searchURI = `https://www.youtube.com/watch?v=${videoID}&list=RD${videoID}&index=${randomIndex}`;
        } while (track.uri.includes(searchURI));
        const res = await player.search(searchURI, player.get("Internal_BotUser"));
        if (res.loadType === "empty" || res.loadType === "error")
            return;
        let tracks = res.tracks;
        if (res.loadType === "playlist") {
            tracks = res.playlist.tracks;
        }
        const foundTrack = tracks.sort(() => Math.random() - 0.5).find((shuffledTrack) => shuffledTrack.uri !== track.uri);
        if (foundTrack) {
            if (this.manager.options.replaceYouTubeCredentials) {
                foundTrack.author = foundTrack.author.replace("- Topic", "");
                foundTrack.title = foundTrack.title.replace("Topic -", "");
                if (foundTrack.title.includes("-")) {
                    const [author, title] = foundTrack.title.split("-").map((str) => str.trim());
                    foundTrack.author = author;
                    foundTrack.title = title;
                }
            }
            player.queue.add(foundTrack);
            player.play();
        }
    }
    // Handle the case when a track failed to load or was cleaned up
    handleFailedTrack(player, track, payload) {
        player.queue.previous = player.queue.current;
        player.queue.current = player.queue.shift();
        if (!player.queue.current) {
            this.queueEnd(player, track, payload);
            return;
        }
        this.manager.emit("trackEnd", player, track, payload);
        if (this.manager.options.autoPlay)
            player.play();
    }
    // Handle the case when a track ended and it's set to repeat (track or queue)
    handleRepeatedTrack(player, track, payload) {
        const { queue, trackRepeat, queueRepeat } = player;
        const { autoPlay } = this.manager.options;
        if (trackRepeat) {
            queue.unshift(queue.current);
        }
        else if (queueRepeat) {
            queue.add(queue.current);
        }
        queue.previous = queue.current;
        queue.current = queue.shift();
        this.manager.emit("trackEnd", player, track, payload);
        if (payload.reason === "stopped" && !(queue.current = queue.shift())) {
            this.queueEnd(player, track, payload);
            return;
        }
        if (autoPlay)
            player.play();
    }
    // Handle the case when there's another track in the queue
    playNextTrack(player, track, payload) {
        player.queue.previous = player.queue.current;
        player.queue.current = player.queue.shift();
        this.manager.emit("trackEnd", player, track, payload);
        if (this.manager.options.autoPlay)
            player.play();
    }
    async queueEnd(player, track, payload) {
        player.queue.previous = player.queue.current;
        player.queue.current = null;
        if (!player.isAutoplay) {
            player.queue.previous = player.queue.current;
            player.queue.current = null;
            player.playing = false;
            this.manager.emit("queueEnd", player, track, payload);
            return;
        }
        await this.handleAutoplay(player, track);
    }
    trackStuck(player, track, payload) {
        player.stop();
        this.manager.emit("trackStuck", player, track, payload);
    }
    trackError(player, track, payload) {
        player.stop();
        this.manager.emit("trackError", player, track, payload);
    }
    socketClosed(player, payload) {
        this.manager.emit("socketClosed", player, payload);
    }
}
exports.Node = Node;
